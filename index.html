<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Level Englisch Vokabel-Spiel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .level-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
        }

        .level-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-color: #667eea;
        }

        .level-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .level-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .level-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
        }

        .highscore {
            background: #e7f3ff;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            color: #0066cc;
        }

        .game-area {
            padding: 30px;
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }

        .timer {
            font-size: 24px;
            font-weight: bold;
            color: #dc3545;
        }

        .progress {
            font-size: 18px;
            color: #667eea;
        }

        /* Level 1: Modern Connection Game */
        .connection-area {
            position: relative;
            height: 600px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
            padding: 20px;
            overflow: hidden;
        }

        .word-card {
            position: absolute;
            padding: 12px 20px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 3px solid transparent;
            min-width: 120px;
            text-align: center;
        }

        .word-card.english {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .word-card.german {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .word-card:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .word-card.selected {
            border-color: #ffd700;
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
        }

        .word-card.matched {
            opacity: 0.7;
            transform: scale(0.9);
            cursor: default;
            filter: brightness(0.8);
        }

        .word-card.dragging {
            transform: scale(1.1) rotate(3deg);
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            z-index: 1000;
            cursor: grabbing;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .connection-line {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            border-radius: 2px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1;
            box-shadow: 0 2px 10px rgba(255,215,0,0.3);
        }

        .connection-line.show {
            opacity: 1;
            animation: drawLine 0.5s ease-out;
        }

        @keyframes drawLine {
            from { width: 0; }
            to { width: var(--line-length); }
        }

        .connection-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            color: #667eea;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .match-animation {
            position: absolute;
            pointer-events: none;
            font-size: 48px;
            z-index: 100;
            animation: matchSuccess 1s ease-out forwards;
        }

        @keyframes matchSuccess {
            0% {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 0;
            }
        }

        .instruction-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .color-legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .legend-color.english {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .legend-color.german {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Level 2: Translation */
        .translation-item {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .translation-input {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            width: 200px;
        }

        .translation-input.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .translation-input.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
        }

        /* Level 3: Crossword */
        .crossword-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .crossword-grid {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            grid-template-rows: repeat(15, 32px);
            gap: 1px;
            background: #333;
            padding: 15px;
            border-radius: 10px;
            position: relative;
        }

        .crossword-cell {
            background: white;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            cursor: pointer;
        }

        .crossword-cell.blocked {
            background: #333;
            border: none;
        }

        .crossword-cell.active {
            background: #fff3cd !important;
        }

        .crossword-cell.current-word {
            background: #e7f3ff;
        }

        .crossword-cell.filled {
            background: #d4edda;
        }

        .crossword-cell input {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .crossword-cell input:focus {
            outline: 2px solid #667eea;
        }

        .crossword-number {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 8px;
            color: #333;
            font-weight: bold;
        }

        .crossword-clues {
            min-width: 300px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .clues-section {
            margin-bottom: 25px;
        }

        .clues-title {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .clue-item {
            padding: 8px 12px;
            margin: 3px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 3px solid transparent;
        }

        .clue-item:hover {
            background: #e9ecef;
            border-left-color: #667eea;
        }

        .clue-item.active {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .clue-item.completed {
            background: #d4edda;
            border-left-color: #28a745;
            opacity: 0.7;
        }

        .clue-number {
            font-weight: bold;
            color: #667eea;
        }

        /* Level 4: AI Description */
        .description-item {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .word-to-describe {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
        }

        .description-input {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            resize: vertical;
        }

        .ai-feedback {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            color: #004085;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: left;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .final-score {
            text-align: center;
            padding: 40px;
        }

        .score-display {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 Multi-Level Englisch Vokabel-Spiel</h1>
            <p>Wähle dein Level und stelle dich der Herausforderung!</p>
        </div>

        <!-- Level Selector -->
        <div class="level-selector" id="levelSelector">
            <div class="level-card" onclick="startLevel(1)">
                <div class="level-icon">🔗</div>
                <div class="level-title">Level 1: Zuordnung</div>
                <div class="level-description">10 Wörter per Klick zuordnen</div>
                <div class="highscore" id="highscore1">Bester: --</div>
            </div>
            
            <div class="level-card" onclick="startLevel(2)">
                <div class="level-icon">✍️</div>
                <div class="level-title">Level 2: Übersetzung</div>
                <div class="level-description">15 deutsche Wörter ins Englische übersetzen</div>
                <div class="highscore" id="highscore2">Bester: --</div>
            </div>
            
            <div class="level-card" onclick="startLevel(3)">
                <div class="level-icon">🧩</div>
                <div class="level-title">Level 3: Kreuzworträtsel</div>
                <div class="level-description">10 Wörter im Kreuzworträtsel finden</div>
                <div class="highscore" id="highscore3">Bester: --</div>
            </div>
            
            <div class="level-card" onclick="startLevel(4)">
                <div class="level-icon">🤖</div>
                <div class="level-title">Level 4: KI-Bewertung</div>
                <div class="level-description">5 Wörter auf Englisch beschreiben</div>
                <div class="highscore" id="highscore4">Bester: --</div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <div class="game-header">
                <button class="btn btn-secondary" onclick="backToMenu()">← Zurück zum Menü</button>
                <div class="progress" id="progress">Frage 1 von 20</div>
                <div class="timer" id="timer">00:00</div>
            </div>
            
            <div id="gameContent"></div>
            
            <div class="final-score hidden" id="finalScore">
                <h2 id="finalTitle">Level abgeschlossen!</h2>
                <div class="score-display" id="finalTime">02:34</div>
                <p id="finalMessage">Gratulation! Du hast einen neuen Rekord aufgestellt!</p>
                <button class="btn btn-primary" onclick="backToMenu()">Zurück zum Menü</button>
                <button class="btn btn-success" onclick="restartLevel()">Level wiederholen</button>
            </div>
        </div>
    </div>

    <script>
        // Vokabeln mit deutschen Übersetzungen
        const vocabulary = [
            {english: "clothing", german: "kleidung"},
            {english: "jumper", german: "pullover"},
            {english: "shoes", german: "schuhe"},
            {english: "trousers", german: "hose"},
            {english: "pants", german: "hose"},
            {english: "blouse", german: "bluse"},
            {english: "cap", german: "mütze"},
            {english: "belt", german: "gürtel"},
            {english: "watch", german: "uhr"},
            {english: "student", german: "schüler"},
            {english: "sunglasses", german: "sonnenbrille"},
            {english: "backpack", german: "rucksack"},
            {english: "school playground", german: "schulhof"},
            {english: "at school", german: "in der schule"},
            {english: "interested", german: "interessiert"},
            {english: "good", german: "gut"},
            {english: "favourite", german: "lieblings"},
            {english: "favorite", german: "lieblings"},
            {english: "subject", german: "fach"},
            {english: "maths", german: "mathematik"},
            {english: "science", german: "naturwissenschaft"},
            {english: "history", german: "geschichte"},
            {english: "art", german: "kunst"},
            {english: "french", german: "französisch"},
            {english: "geography", german: "geografie"},
            {english: "also", german: "auch"},
            {english: "passion", german: "leidenschaft"},
            {english: "practice", german: "üben"},
            {english: "effort", german: "anstrengung"},
            {english: "proud", german: "stolz"},
            {english: "spend", german: "verbringen"},
            {english: "every day", german: "jeden tag"},
            {english: "at the weekend", german: "am wochenende"},
            {english: "a lot of", german: "viel"},
            {english: "feel", german: "fühlen"},
            {english: "jewellery", german: "schmuck"},
            {english: "exciting", german: "aufregend"},
            {english: "passionate", german: "leidenschaftlich"},
            {english: "inventor", german: "erfinder"},
            {english: "solve a problem", german: "ein problem lösen"},
            {english: "invention", german: "erfindung"}
        ];

        // Game state
        let currentLevel = 0;
        let gameData = [];
        let startTime = 0;
        let timerInterval = null;
        let currentProgress = 0;

        // Firebase config
        const FIREBASE_URL = "https://wortartenspiele-default-rtdb.europe-west1.firebasedatabase.app";
        const GEMINI_API_KEY = "AIzaSyAJ52b330dLaXxZPcLPx8tt7jdl0sdB-2k";

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadHighscores();
        });

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timer').textContent = formatTime(elapsed);
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            return Math.floor((Date.now() - startTime) / 1000);
        }

        function updateProgress(current, total) {
            currentProgress = current;
            document.getElementById('progress').textContent = `${current} von ${total}`;
        }

        async function loadHighscores() {
            try {
                for (let i = 1; i <= 4; i++) {
                    const response = await fetch(`${FIREBASE_URL}/highscores/level${i}.json`);
                    const data = await response.json();
                    const element = document.getElementById(`highscore${i}`);
                    if (data && data.time) {
                        element.textContent = `Bester: ${formatTime(data.time)}`;
                    }
                }
            } catch (error) {
                console.error('Fehler beim Laden der Highscores:', error);
            }
        }

        async function saveHighscore(level, time) {
            try {
                // Aktuellen Highscore laden
                const response = await fetch(`${FIREBASE_URL}/highscores/level${level}.json`);
                const currentHighscore = await response.json();
                
                // Nur speichern wenn es ein neuer Rekord ist
                if (!currentHighscore || !currentHighscore.time || time < currentHighscore.time) {
                    await fetch(`${FIREBASE_URL}/highscores/level${level}.json`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            time: time,
                            timestamp: Date.now()
                        })
                    });
                    
                    // UI aktualisieren
                    document.getElementById(`highscore${level}`).textContent = `Bester: ${formatTime(time)}`;
                    return true; // Neuer Rekord
                }
                return false; // Kein neuer Rekord
            } catch (error) {
                console.error('Fehler beim Speichern des Highscores:', error);
                return false;
            }
        }

        function startLevel(level) {
            currentLevel = level;
            document.getElementById('levelSelector').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';
            document.getElementById('finalScore').classList.add('hidden');
            
            startTimer();
            
            switch(level) {
                case 1: initLevel1(); break;
                case 2: initLevel2(); break;
                case 3: initLevel3(); break;
                case 4: initLevel4(); break;
            }
        }

        function backToMenu() {
            stopTimer();
            document.getElementById('levelSelector').style.display = 'grid';
            document.getElementById('gameArea').style.display = 'none';
        }

        function restartLevel() {
            document.getElementById('finalScore').classList.add('hidden');
            startLevel(currentLevel);
        }

        // LEVEL 1: Modern Connection Game
        function initLevel1() {
            const selectedWords = shuffleArray(vocabulary).slice(0, 10); // Reduziert auf 10 Wörter
            gameData = selectedWords;
            
            updateProgress(0, 10);
            
            const content = `
                <div class="instruction-panel">
                    <h3>🔗 Ziehe zusammengehörende Wörter aufeinander!</h3>
                    <p>Verschiebe die Karten frei und bringe richtige Paare zusammen.</p>
                    <div class="color-legend">
                        <div class="legend-item">
                            <div class="legend-color english"></div>
                            <span>Englisch</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color german"></div>
                            <span>Deutsch</span>
                        </div>
                    </div>
                </div>
                <div class="connection-area" id="connectionArea">
                    <div class="connection-counter">
                        <span id="matchCounter">0</span> / 10 Paare
                    </div>
                </div>
            `;
            
            document.getElementById('gameContent').innerHTML = content;
            setupConnectionGame(selectedWords);
        }

        function setupConnectionGame(words) {
            const area = document.getElementById('connectionArea');
            let matchedPairs = 0;
            let draggedCard = null;
            
            // Englische Wörter verteilen (linke Hälfte)
            words.forEach((word, index) => {
                const englishCard = document.createElement('div');
                englishCard.className = 'word-card english';
                englishCard.textContent = word.english;
                englishCard.dataset.word = word.english;
                englishCard.dataset.correct = word.german;
                englishCard.draggable = true;
                
                // Zufällige Position in der linken Hälfte
                const x = Math.random() * 250; // 0-250px (linke Hälfte)
                const y = Math.random() * 500; // 0-500px (ganze Höhe)
                
                englishCard.style.left = x + 'px';
                englishCard.style.top = y + 'px';
                
                setupDragEvents(englishCard);
                area.appendChild(englishCard);
            });
            
            // Deutsche Wörter verteilen (rechte Hälfte)
            const shuffledGerman = shuffleArray([...words]);
            shuffledGerman.forEach((word, index) => {
                const germanCard = document.createElement('div');
                germanCard.className = 'word-card german';
                germanCard.textContent = word.german;
                germanCard.dataset.word = word.german;
                germanCard.dataset.english = word.english;
                germanCard.draggable = true;
                
                // Zufällige Position in der rechten Hälfte
                const x = 350 + Math.random() * 250; // 350-600px (rechte Hälfte)
                const y = Math.random() * 500; // 0-500px (ganze Höhe)
                
                germanCard.style.left = x + 'px';
                germanCard.style.top = y + 'px';
                
                setupDragEvents(germanCard);
                area.appendChild(germanCard);
            });
            
            function setupDragEvents(card) {
                let isDragging = false;
                let startX, startY, initialX, initialY;
                
                // Mouse Events
                card.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
                
                // Touch Events für Mobile
                card.addEventListener('touchstart', startDrag, { passive: false });
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('touchend', endDrag);
                
                function startDrag(e) {
                    if (card.classList.contains('matched')) return;
                    
                    isDragging = true;
                    draggedCard = card;
                    card.classList.add('dragging');
                    card.style.zIndex = '1000';
                    
                    const clientX = e.clientX || e.touches[0].clientX;
                    const clientY = e.clientY || e.touches[0].clientY;
                    
                    startX = clientX;
                    startY = clientY;
                    initialX = parseInt(card.style.left);
                    initialY = parseInt(card.style.top);
                    
                    e.preventDefault();
                }
                
                function drag(e) {
                    if (!isDragging || !draggedCard) return;
                    
                    const clientX = e.clientX || e.touches[0].clientX;
                    const clientY = e.clientY || e.touches[0].clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;
                    
                    draggedCard.style.left = (initialX + deltaX) + 'px';
                    draggedCard.style.top = (initialY + deltaY) + 'px';
                    
                    e.preventDefault();
                }
                
                function endDrag(e) {
                    if (!isDragging || !draggedCard) return;
                    
                    isDragging = false;
                    draggedCard.classList.remove('dragging');
                    draggedCard.style.zIndex = '10';
                    
                    // Prüfe Kollision mit anderen Karten
                    checkForMatch(draggedCard);
                    
                    draggedCard = null;
                }
            }
            
            function checkForMatch(movedCard) {
                const movedRect = movedCard.getBoundingClientRect();
                const allCards = document.querySelectorAll('.word-card:not(.matched)');
                
                for (let otherCard of allCards) {
                    if (otherCard === movedCard) continue;
                    
                    const otherRect = otherCard.getBoundingClientRect();
                    
                    // Prüfe Überlappung
                    if (isOverlapping(movedRect, otherRect)) {
                        // Prüfe ob es ein korrektes Paar ist
                        if (isCorrectMatch(movedCard, otherCard)) {
                            handleCorrectMatch(movedCard, otherCard);
                            matchedPairs++;
                            updateProgress(matchedPairs, 10);
                            document.getElementById('matchCounter').textContent = matchedPairs;
                            
                            if (matchedPairs === 10) {
                                setTimeout(() => finishLevel(), 1000);
                            }
                            return;
                        } else {
                            // Falsches Paar - Cards zurückfedern lassen
                            handleIncorrectMatch(movedCard, otherCard);
                            return;
                        }
                    }
                }
            }
            
            function isOverlapping(rect1, rect2) {
                const overlap = !(rect1.right < rect2.left || 
                                rect1.left > rect2.right || 
                                rect1.bottom < rect2.top || 
                                rect1.top > rect2.bottom);
                
                if (overlap) {
                    // Prüfe ob mindestens 30% Überlappung vorhanden
                    const overlapArea = Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left)) *
                                      Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));
                    const minArea = Math.min(rect1.width * rect1.height, rect2.width * rect2.height);
                    
                    return overlapArea / minArea > 0.3; // 30% Überlappung erforderlich
                }
                return false;
            }
            
            function isCorrectMatch(card1, card2) {
                const english1 = card1.classList.contains('english') ? card1.dataset.word : card1.dataset.english;
                const german1 = card1.classList.contains('german') ? card1.dataset.word : card1.dataset.correct;
                
                const english2 = card2.classList.contains('english') ? card2.dataset.word : card2.dataset.english;
                const german2 = card2.classList.contains('german') ? card2.dataset.word : card2.dataset.correct;
                
                return (english1 === english2 && german1 === german2) ||
                       (card1.classList.contains('english') && card2.classList.contains('german') && card1.dataset.correct === card2.dataset.word) ||
                       (card1.classList.contains('german') && card2.classList.contains('english') && card1.dataset.english === card2.dataset.word);
            }
            
            function handleCorrectMatch(card1, card2) {
                // Success Animation und dann verschwinden lassen
                showMatchAnimation(card1, card2);
                
                // Karten zum Zentrum bewegen und verkleinern
                const centerX = (parseFloat(card1.style.left) + parseFloat(card2.style.left)) / 2;
                const centerY = (parseFloat(card1.style.top) + parseFloat(card2.style.top)) / 2;
                
                card1.style.transition = 'all 0.6s ease-out';
                card2.style.transition = 'all 0.6s ease-out';
                
                card1.style.left = centerX + 'px';
                card1.style.top = centerY + 'px';
                card1.style.transform = 'scale(0.8)';
                
                card2.style.left = centerX + 'px';
                card2.style.top = centerY + 'px';
                card2.style.transform = 'scale(0.8)';
                
                card1.classList.add('matched');
                card2.classList.add('matched');
                
                // Nach Animation entfernen
                setTimeout(() => {
                    card1.style.transition = 'all 0.4s ease-in';
                    card2.style.transition = 'all 0.4s ease-in';
                    card1.style.transform = 'scale(0) rotate(360deg)';
                    card2.style.transform = 'scale(0) rotate(-360deg)';
                    card1.style.opacity = '0';
                    card2.style.opacity = '0';
                    
                    setTimeout(() => {
                        card1.remove();
                        card2.remove();
                    }, 400);
                }, 600);
            }
            
            function handleIncorrectMatch(card1, card2) {
                // Shake Animation
                card1.style.animation = 'shake 0.5s ease-in-out';
                card2.style.animation = 'shake 0.5s ease-in-out';
                
                setTimeout(() => {
                    card1.style.animation = '';
                    card2.style.animation = '';
                }, 500);
            }
            
            function showMatchAnimation(card1, card2) {
                const emoji = document.createElement('div');
                emoji.className = 'match-animation';
                emoji.textContent = '🎉';
                emoji.style.fontSize = '64px';
                
                const centerX = (parseFloat(card1.style.left) + parseFloat(card2.style.left)) / 2;
                const centerY = (parseFloat(card1.style.top) + parseFloat(card2.style.top)) / 2;
                
                emoji.style.left = centerX + 'px';
                emoji.style.top = (centerY - 30) + 'px';
                
                area.appendChild(emoji);
                
                setTimeout(() => emoji.remove(), 1000);
            }
        }

        // Shake-Animation zu CSS hinzufügen
        const shakeKeyframes = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-10px); }
                75% { transform: translateX(10px); }
            }
        `;
        
        if (!document.querySelector('#shake-keyframes')) {
            const style = document.createElement('style');
            style.id = 'shake-keyframes';
            style.textContent = shakeKeyframes;
            document.head.appendChild(style);
        }

        // LEVEL 2: Translation
        function initLevel2() {
            const selectedWords = shuffleArray(vocabulary).slice(0, 15);
            gameData = selectedWords;
            
            updateProgress(0, 15);
            
            const content = `
                <div>
                    <h3 style="text-align: center; margin-bottom: 30px;">Übersetze die deutschen Wörter ins Englische:</h3>
                    ${selectedWords.map((word, index) => 
                        `<div class="translation-item">
                            <strong>${word.german}</strong>
                            <input type="text" class="translation-input" data-correct="${word.english}" 
                                   placeholder="Englische Übersetzung..." oninput="checkTranslation(this)">
                        </div>`
                    ).join('')}
                </div>
            `;
            
            document.getElementById('gameContent').innerHTML = content;
        }

        function checkTranslation(input) {
            const userAnswer = input.value.trim().toLowerCase();
            const correctAnswer = input.dataset.correct.toLowerCase();
            
            input.classList.remove('correct', 'incorrect');
            
            if (userAnswer && userAnswer === correctAnswer) {
                input.classList.add('correct');
                
                // Fortschritt prüfen
                const correct = document.querySelectorAll('.translation-input.correct').length;
                updateProgress(correct, 15);
                
                if (correct === 15) {
                    finishLevel();
                }
            } else if (userAnswer) {
                input.classList.add('incorrect');
            }
        }

        // LEVEL 3: Dynamic Crossword Generator
        function initLevel3() {
            // 10 zufällige Wörter auswählen
            const selectedWords = shuffleArray(vocabulary).slice(0, 10);
            
            // Kreative Hinweise für alle Wörter generieren
            const wordClues = generateCluesForWords(selectedWords);
            
            // Dynamisches Kreuzworträtsel Layout erstellen
            const crosswordData = generateDynamicCrossword(wordClues);
            
            gameData = crosswordData;
            updateProgress(0, 10);
            
            const content = `
                <div class="crossword-container">
                    <div class="crossword-grid" id="crosswordGrid">
                        ${generateCrosswordHTML(crosswordData)}
                    </div>
                    <div class="crossword-clues">
                        <div class="clues-section">
                            <div class="clues-title">WAAGERECHT</div>
                            ${crosswordData.words.filter(w => w.direction === 'across').map(word => 
                                `<div class="clue-item" data-word-id="${word.number}" onclick="selectWord(${word.number})">
                                    <span class="clue-number">${word.number}.</span> ${word.clue}
                                </div>`
                            ).join('')}
                        </div>
                        <div class="clues-section">
                            <div class="clues-title">SENKRECHT</div>
                            ${crosswordData.words.filter(w => w.direction === 'down').map(word => 
                                `<div class="clue-item" data-word-id="${word.number}" onclick="selectWord(${word.number})">
                                    <span class="clue-number">${word.number}.</span> ${word.clue}
                                </div>`
                            ).join('')}
                        </div>
                        <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 10px;">
                            <strong>Anleitung:</strong><br>
                            • Klicke auf einen Hinweis<br>
                            • Tippe das Wort ins Rätsel<br>
                            • Benutze Pfeiltasten zum Navigieren
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('gameContent').innerHTML = content;
            initCrosswordEvents();
        }

        function generateCluesForWords(words) {
            const clueTemplates = {
                // Kleidung
                "clothing": "General term for what you wear",
                "jumper": "Warm garment for your upper body",
                "shoes": "Footwear you put on your feet",
                "trousers": "Clothing item covering your legs",
                "pants": "American word for leg covering",
                "blouse": "Elegant shirt often worn by women",
                "cap": "Hat with a visor",
                "belt": "Accessory worn around your waist",
                "watch": "Device worn on wrist to tell time",
                "sunglasses": "Eye protection from bright light",
                "jewellery": "Decorative items like rings and necklaces",
                
                // Schule
                "student": "Person who learns at school or university",
                "backpack": "Bag carried on your back for books",
                "school playground": "Outdoor area where children play at school",
                "at school": "Location where you go to learn",
                "subject": "What you study, like math or history",
                "maths": "Subject involving numbers and calculations",
                "science": "Subject involving experiments and discoveries",
                "history": "Subject about events from the past",
                "art": "Creative subject involving drawing and painting",
                "french": "Language spoken in France",
                "geography": "Subject about countries and maps",
                
                // Eigenschaften & Gefühle
                "interested": "Curious and wanting to know more",
                "good": "The opposite of bad",
                "favourite": "The one you like most",
                "favorite": "American spelling of preferred choice",
                "exciting": "Thrilling and full of energy",
                "passionate": "Having strong enthusiasm for something",
                "proud": "Feeling satisfied with an achievement",
                
                // Aktivitäten & Zeit
                "practice": "Do something repeatedly to improve",
                "effort": "Energy and hard work you put into something",
                "spend": "Use time or money for something",
                "every day": "Each day without exception",
                "at the weekend": "During Saturday and Sunday",
                "feel": "Experience an emotion",
                
                // Andere
                "also": "In addition to, as well",
                "passion": "Strong enthusiasm or love for something",
                "a lot of": "Many or much",
                "inventor": "Person who creates new things",
                "solve a problem": "Find an answer to a difficulty",
                "invention": "Something new that someone created"
            };
            
            return words.map(word => ({
                word: word.english.toUpperCase().replace(/\s+/g, ''),
                originalWord: word.english,
                clue: clueTemplates[word.english] || `German: ${word.german}`
            }));
        }

        function generateDynamicCrossword(wordClues) {
            // Sortiere Wörter nach Länge (längste zuerst für bessere Platzierung)
            const sortedWords = [...wordClues].sort((a, b) => b.word.length - a.word.length);
            
            const gridSize = 15;
            const grid = Array(gridSize).fill().map(() => Array(gridSize).fill('#'));
            const placedWords = [];
            
            // Erstes (längstes) Wort horizontal in der Mitte platzieren
            const firstWord = sortedWords[0];
            const startRow = Math.floor(gridSize / 2);
            const startCol = Math.floor((gridSize - firstWord.word.length) / 2);
            
            // Erstes Wort platzieren
            for (let i = 0; i < firstWord.word.length; i++) {
                grid[startRow][startCol + i] = {
                    letter: firstWord.word[i],
                    number: i === 0 ? 1 : null,
                    wordId: 1,
                    position: i
                };
            }
            
            placedWords.push({
                word: firstWord.word,
                clue: firstWord.clue,
                row: startRow,
                col: startCol,
                direction: 'across',
                number: 1
            });
            
            let wordNumber = 2;
            
            // Versuche restliche Wörter zu platzieren - maximal 9 weitere (= 10 total)
            for (let wordIndex = 1; wordIndex < sortedWords.length && placedWords.length < 10; wordIndex++) {
                const currentWord = sortedWords[wordIndex];
                let placed = false;
                
                // Versuche das Wort zu platzieren (mit bereits platzierten Wörtern kreuzend)
                for (const placedWord of placedWords) {
                    if (placed) break;
                    
                    // Versuche Kreuzung zu finden
                    for (let i = 0; i < currentWord.word.length; i++) {
                        for (let j = 0; j < placedWord.word.length; j++) {
                            if (currentWord.word[i] === placedWord.word[j]) {
                                // Mögliche Kreuzung gefunden
                                let newRow, newCol, direction;
                                
                                if (placedWord.direction === 'across') {
                                    // Platziere vertikal
                                    direction = 'down';
                                    newRow = placedWord.row - i;
                                    newCol = placedWord.col + j;
                                } else {
                                    // Platziere horizontal
                                    direction = 'across';
                                    newRow = placedWord.row + j;
                                    newCol = placedWord.col - i;
                                }
                                
                                // Prüfe ob Platzierung möglich ist
                                if (canPlaceWord(grid, currentWord.word, newRow, newCol, direction, gridSize)) {
                                    // Wort platzieren
                                    for (let k = 0; k < currentWord.word.length; k++) {
                                        const r = direction === 'across' ? newRow : newRow + k;
                                        const c = direction === 'across' ? newCol + k : newCol;
                                        
                                        if (grid[r][c] === '#') {
                                            grid[r][c] = {
                                                letter: currentWord.word[k],
                                                number: k === 0 ? wordNumber : null,
                                                wordId: wordNumber,
                                                position: k
                                            };
                                        } else {
                                            // Kreuzung - aber behalte ursprüngliche Struktur
                                            if (k === 0) {
                                                grid[r][c].number = wordNumber;
                                            }
                                        }
                                    }
                                    
                                    placedWords.push({
                                        word: currentWord.word,
                                        clue: currentWord.clue,
                                        row: newRow,
                                        col: newCol,
                                        direction: direction,
                                        number: wordNumber
                                    });
                                    
                                    wordNumber++;
                                    placed = true;
                                    break;
                                }
                            }
                        }
                        if (placed) break;
                    }
                }
                
                // Falls keine Kreuzung möglich, versuche freie Platzierung (nur wenn weniger als 8 Wörter)
                if (!placed && placedWords.length < 8) {
                    const placement = findFreeSpace(grid, currentWord.word, gridSize);
                    if (placement) {
                        // Wort an freier Stelle platzieren
                        for (let k = 0; k < currentWord.word.length; k++) {
                            const r = placement.direction === 'across' ? placement.row : placement.row + k;
                            const c = placement.direction === 'across' ? placement.col + k : placement.col;
                            
                            grid[r][c] = {
                                letter: currentWord.word[k],
                                number: k === 0 ? wordNumber : null,
                                wordId: wordNumber,
                                position: k
                            };
                        }
                        
                        placedWords.push({
                            word: currentWord.word,
                            clue: currentWord.clue,
                            row: placement.row,
                            col: placement.col,
                            direction: placement.direction,
                            number: wordNumber
                        });
                        
                        wordNumber++;
                    }
                }
            }
            
            // Sicherstellen, dass wir genau die richtige Anzahl haben
            console.log(`Platzierte Wörter: ${placedWords.length}`);
            console.log('Waagerecht:', placedWords.filter(w => w.direction === 'across').length);
            console.log('Senkrecht:', placedWords.filter(w => w.direction === 'down').length);
            
            return {
                words: placedWords,
                grid: grid
            };
        }

        function canPlaceWord(grid, word, row, col, direction, gridSize) {
            if (row < 0 || col < 0) return false;
            
            // Prüfe ob das ganze Wort ins Grid passt
            const endRow = direction === 'across' ? row : row + word.length - 1;
            const endCol = direction === 'across' ? col + word.length - 1 : col;
            
            if (endRow >= gridSize || endCol >= gridSize) return false;
            
            // Prüfe jeden Buchstaben
            for (let i = 0; i < word.length; i++) {
                const r = direction === 'across' ? row : row + i;
                const c = direction === 'across' ? col + i : col;
                
                const cell = grid[r][c];
                
                // Feld muss leer sein oder denselben Buchstaben haben (Kreuzung)
                if (cell !== '#' && cell.letter !== word[i]) {
                    return false;
                }
                
                // Prüfe Nachbarzellen (keine benachbarten Wörter)
                if (cell === '#') {
                    const neighbors = [
                        [r-1, c], [r+1, c], [r, c-1], [r, c+1]
                    ];
                    
                    for (const [nr, nc] of neighbors) {
                        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                            if (grid[nr][nc] !== '#') {
                                // Nachbar ist besetzt - prüfe ob das eine gewollte Kreuzung ist
                                const isPartOfCurrentWord = (
                                    (direction === 'across' && nr === r && Math.abs(nc - c) === 1) ||
                                    (direction === 'down' && nc === c && Math.abs(nr - r) === 1)
                                );
                                
                                if (!isPartOfCurrentWord) {
                                    // Ungewollte Nachbarschaft
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        function findFreeSpace(grid, word, gridSize) {
            const directions = shuffleArray(['across', 'down']);
            
            for (const direction of directions) {
                const positions = [];
                
                // Alle möglichen Positionen sammeln
                for (let row = 2; row < gridSize - 2; row++) {
                    for (let col = 2; col < gridSize - 2; col++) {
                        if (canPlaceWord(grid, word, row, col, direction, gridSize)) {
                            positions.push({ row, col, direction });
                        }
                    }
                }
                
                // Zufällige Position wählen
                if (positions.length > 0) {
                    return positions[Math.floor(Math.random() * positions.length)];
                }
            }
            
            return null;
        }

        function generateCrosswordHTML(crosswordData) {
            let html = '';
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const cell = crosswordData.grid[row][col];
                    if (cell === '#') {
                        html += '<div class="crossword-cell blocked"></div>';
                    } else {
                        const wordIds = cell.wordId.toString().split(',');
                        html += `
                            <div class="crossword-cell" data-row="${row}" data-col="${col}" 
                                 data-word-id="${wordIds[0]}" data-position="${cell.position}">
                                ${cell.number ? `<div class="crossword-number">${cell.number}</div>` : ''}
                                <input type="text" maxlength="1" data-answer="${cell.letter}">
                            </div>
                        `;
                    }
                }
            }
            return html;
        }

        let currentSelectedWord = null;

        function initCrosswordEvents() {
            const inputs = document.querySelectorAll('.crossword-cell input');
            
            inputs.forEach(input => {
                // Klick-Event für Fokus
                input.addEventListener('click', (e) => {
                    e.target.focus();
                    const wordId = e.target.parentElement.dataset.wordId;
                    selectWord(wordId);
                });
                
                // Input-Event für Buchstabeneingabe
                input.addEventListener('input', (e) => {
                    let value = e.target.value.toUpperCase();
                    
                    // Nur Buchstaben erlauben
                    value = value.replace(/[^A-Z]/g, '');
                    
                    if (value.length > 1) {
                        value = value.slice(-1); // Nur letzten Buchstaben behalten
                    }
                    
                    e.target.value = value;
                    
                    const correct = e.target.dataset.answer;
                    
                    // Visuelles Feedback
                    e.target.parentElement.classList.remove('filled');
                    if (value === correct) {
                        e.target.parentElement.classList.add('filled');
                        // Automatisch zum nächsten Feld
                        moveToNextCell(e.target);
                    }
                    
                    checkCrosswordCompletion();
                });
                
                // Keydown für Navigation und Löschen
                input.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowRight':
                            e.preventDefault();
                            navigateGrid(e.target, 0, 1);
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            navigateGrid(e.target, 0, -1);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            navigateGrid(e.target, 1, 0);
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            navigateGrid(e.target, -1, 0);
                            break;
                        case 'Backspace':
                            // Wenn Feld leer ist, gehe zum vorherigen Feld
                            if (!e.target.value) {
                                e.preventDefault();
                                moveToPreviousCell(e.target);
                            } else {
                                // Feld wird automatisch geleert
                                e.target.parentElement.classList.remove('filled');
                            }
                            break;
                        case 'Delete':
                            e.target.value = '';
                            e.target.parentElement.classList.remove('filled');
                            checkCrosswordCompletion();
                            break;
                        case 'Tab':
                            e.preventDefault();
                            if (e.shiftKey) {
                                moveToPreviousCell(e.target);
                            } else {
                                moveToNextCell(e.target);
                            }
                            break;
                        case 'Enter':
                            e.preventDefault();
                            moveToNextCell(e.target);
                            break;
                        case 'Escape':
                            e.target.blur();
                            break;
                    }
                });
                
                // Focus-Event
                input.addEventListener('focus', (e) => {
                    const wordId = e.target.parentElement.dataset.wordId;
                    selectWord(wordId);
                    e.target.select(); // Text auswählen für einfaches Überschreiben
                });
            });
        }

        // Navigation im Grid (Pfeiltasten)
        function navigateGrid(currentInput, rowDelta, colDelta) {
            const currentCell = currentInput.parentElement;
            const currentRow = parseInt(currentCell.dataset.row);
            const currentCol = parseInt(currentCell.dataset.col);
            
            const newRow = currentRow + rowDelta;
            const newCol = currentCol + colDelta;
            
            // Suche nächstes verfügbares Feld
            const targetCell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
            
            if (targetCell && !targetCell.classList.contains('blocked')) {
                const targetInput = targetCell.querySelector('input');
                if (targetInput) {
                    targetInput.focus();
                    targetInput.select();
                }
            }
        }

        // Navigation innerhalb eines Wortes (automatisch nach Eingabe)
        function moveToNextCell(currentInput) {
            const currentCell = currentInput.parentElement;
            const wordId = currentCell.dataset.wordId;
            const position = parseInt(currentCell.dataset.position);
            
            // Suche nächste Position im selben Wort
            const nextCell = document.querySelector(`[data-word-id="${wordId}"][data-position="${position + 1}"]`);
            
            if (nextCell) {
                const nextInput = nextCell.querySelector('input');
                if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                    return;
                }
            }
            
            // Wenn kein nächstes Feld im Wort, suche nächstes leeres Feld
            const allInputs = document.querySelectorAll('.crossword-cell input');
            for (let input of allInputs) {
                if (!input.value) {
                    input.focus();
                    input.select();
                    break;
                }
            }
        }

        function moveToPreviousCell(currentInput) {
            const currentCell = currentInput.parentElement;
            const wordId = currentCell.dataset.wordId;
            const position = parseInt(currentCell.dataset.position);
            
            // Suche vorherige Position im selben Wort
            const prevCell = document.querySelector(`[data-word-id="${wordId}"][data-position="${position - 1}"]`);
            
            if (prevCell) {
                const prevInput = prevCell.querySelector('input');
                if (prevInput) {
                    prevInput.focus();
                    prevInput.select();
                    return;
                }
            }
            
            // Wenn kein vorheriges Feld im Wort, suche letztes ausgefülltes Feld
            const allInputs = Array.from(document.querySelectorAll('.crossword-cell input')).reverse();
            for (let input of allInputs) {
                if (input.value && input !== currentInput) {
                    input.focus();
                    input.select();
                    break;
                }
            }
        }

        function selectWord(wordId) {
            if (!wordId) return;
            
            // Alle Hervorhebungen entfernen
            document.querySelectorAll('.crossword-cell').forEach(cell => {
                cell.classList.remove('current-word', 'active');
            });
            document.querySelectorAll('.clue-item').forEach(clue => {
                clue.classList.remove('active');
            });
            
            // Aktuelles Wort und Hinweis hervorheben
            document.querySelectorAll(`[data-word-id="${wordId}"]`).forEach(element => {
                if (element.classList.contains('crossword-cell')) {
                    element.classList.add('current-word');
                } else if (element.classList.contains('clue-item')) {
                    element.classList.add('active');
                }
            });
            
            currentSelectedWord = wordId;
        }

        function checkCrosswordCompletion() {
            const allInputs = document.querySelectorAll('.crossword-cell:not(.blocked) input');
            const correctInputs = Array.from(allInputs).filter(input => {
                return input.value.toUpperCase() === input.dataset.answer;
            });
            
            updateProgress(correctInputs.length, allInputs.length);
            
            // Level ist abgeschlossen wenn alle Felder korrekt sind
            if (correctInputs.length === allInputs.length && allInputs.length > 0) {
                // Alle Wörter als abgeschlossen markieren
                document.querySelectorAll('.clue-item').forEach(clue => {
                    clue.classList.add('completed');
                });
                
                setTimeout(() => {
                    finishLevel();
                }, 500);
            }
        }

        // LEVEL 4: AI Description
        function initLevel4() {
            const selectedWords = shuffleArray(vocabulary).slice(0, 5);
            gameData = selectedWords;
            currentProgress = 0;
            
            updateProgress(0, 5);
            showNextDescription();
        }

        function showNextDescription() {
            if (currentProgress >= 5) {
                finishLevel();
                return;
            }
            
            const word = gameData[currentProgress];
            
            const content = `
                <div class="description-item">
                    <div class="word-to-describe">${word.english}</div>
                    <p style="margin-bottom: 20px;">Beschreibe dieses Wort auf Englisch:</p>
                    <textarea class="description-input" id="descriptionInput" 
                              placeholder="Write your description in English..."></textarea>
                    <div>
                        <button class="btn btn-primary" onclick="checkDescription()">
                            Beschreibung prüfen
                        </button>
                    </div>
                    <div id="aiFeedback"></div>
                </div>
            `;
            
            document.getElementById('gameContent').innerHTML = content;
            document.getElementById('descriptionInput').focus();
        }

        async function checkDescription() {
            const description = document.getElementById('descriptionInput').value.trim();
            
            if (!description) {
                alert('Bitte gib eine Beschreibung ein!');
                return;
            }
            
            const feedbackElement = document.getElementById('aiFeedback');
            feedbackElement.innerHTML = '<div class="ai-feedback"><div class="loading"></div> KI bewertet deine Beschreibung...</div>';
            
            try {
                const word = gameData[currentProgress];
                const aiResult = await evaluateWithAI(word.english, description);
                
                feedbackElement.innerHTML = `
                    <div class="ai-feedback">
                        <strong>KI-Bewertung:</strong> ${aiResult.feedback}
                        <div style="margin-top: 10px;">
                            <button class="btn btn-success" onclick="nextDescription()">
                                Weiter zur nächsten Aufgabe
                            </button>
                        </div>
                    </div>
                `;
            } catch (error) {
                feedbackElement.innerHTML = `
                    <div class="ai-feedback">
                        <strong>Fehler:</strong> KI-Bewertung nicht verfügbar. 
                        <button class="btn btn-success" onclick="nextDescription()">
                            Trotzdem weiter
                        </button>
                    </div>
                `;
            }
        }

        function nextDescription() {
            currentProgress++;
            updateProgress(currentProgress, 5);
            showNextDescription();
        }

        async function evaluateWithAI(word, userDefinition) {
            const prompt = `Bewerte diese englische Definition eines deutschen Schülers kurz und motivierend:
            
Wort: "${word}"
Definition des Schülers: "${userDefinition}"

Gib eine kurze, positive Bewertung auf Deutsch (max. 2 Sätze).`;

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            const data = await response.json();
            const feedback = data.candidates[0].content.parts[0].text;
            
            return { feedback: feedback.trim() };
        }

        async function finishLevel() {
            const finalTime = stopTimer();
            const isNewRecord = await saveHighscore(currentLevel, finalTime);
            
            document.getElementById('finalTitle').textContent = `Level ${currentLevel} abgeschlossen!`;
            document.getElementById('finalTime').textContent = formatTime(finalTime);
            document.getElementById('finalMessage').textContent = isNewRecord ? 
                '🏆 Gratulation! Du hast einen neuen Rekord aufgestellt!' : 
                '👍 Gut gemacht! Versuche es nochmal für einen neuen Rekord!';
            
            document.getElementById('gameContent').style.display = 'none';
            document.getElementById('finalScore').classList.remove('hidden');
        }
    </script>
</body>
</html>
